#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -f lz-kernel-manager lz-k-installer lz-km-sign lz-km-build lz-kmconfig 
#endif

static  char data [] = 
#define      lsto_z	1
#define      lsto	((&data[0]))
	"\244"
#define      rlax_z	1
#define      rlax	((&data[1]))
	"\173"
#define      tst2_z	19
#define      tst2	((&data[5]))
	"\245\003\017\107\255\363\270\120\066\372\006\060\247\205\245\355"
	"\226\173\022\042\275\033\061\207\021"
#define      chk2_z	19
#define      chk2	((&data[30]))
	"\272\103\101\007\257\106\323\341\262\336\266\226\065\002\263\315"
	"\216\242\367\005\200\075\006\100"
#define      msg1_z	65
#define      msg1	((&data[58]))
	"\137\273\065\352\072\252\045\237\006\264\325\356\177\202\227\075"
	"\007\066\273\116\205\125\233\220\135\323\052\266\014\303\101\215"
	"\326\275\300\345\216\050\063\142\300\135\037\007\056\100\160\252"
	"\151\161\237\004\300\015\034\156\021\330\361\064\157\253\130\113"
	"\240\345\345\110\173\073\261\331\332\136\037\015\115\314\266\362"
	"\317"
#define      opts_z	1
#define      opts	((&data[132]))
	"\326"
#define      text_z	1686
#define      text	((&data[173]))
	"\154\323\105\256\331\206\316\115\030\056\011\115\030\103\370\076"
	"\036\127\135\053\244\051\341\227\370\247\273\117\177\324\122\354"
	"\247\230\232\201\036\151\317\067\132\126\176\121\102\126\124\154"
	"\032\053\232\307\042\061\364\257\310\306\014\203\371\133\331\357"
	"\151\360\326\321\101\052\313\003\032\354\212\377\264\052\110\151"
	"\040\266\336\010\003\144\365\043\061\115\312\146\343\316\072\160"
	"\344\034\122\140\042\377\271\064\307\325\040\273\147\244\216\266"
	"\156\214\243\114\036\264\265\005\232\340\344\060\015\255\031\264"
	"\346\050\012\325\310\205\323\131\165\274\033\155\254\271\306\320"
	"\064\135\347\275\314\241\075\155\225\330\352\223\016\360\023\101"
	"\021\054\011\323\377\245\377\137\252\017\314\045\024\365\160\023"
	"\365\211\022\045\303\135\252\304\133\041\126\251\253\377\241\266"
	"\172\355\255\263\141\223\216\112\176\227\360\103\051\300\337\300"
	"\144\127\235\157\277\341\020\374\316\074\271\117\321\067\025\115"
	"\071\306\220\162\314\300\216\235\056\164\077\234\223\012\371\047"
	"\126\270\312\235\053\071\335\255\020\131\263\234\052\202\375\316"
	"\251\052\116\157\125\203\220\374\274\270\337\315\365\120\254\302"
	"\236\347\271\333\215\200\217\245\054\222\063\373\244\241\125\165"
	"\350\130\333\105\245\371\015\257\106\207\356\076\007\056\200\023"
	"\311\156\224\104\047\205\103\000\034\020\273\211\165\042\063\015"
	"\050\335\324\153\273\371\103\120\054\160\337\132\020\166\324\043"
	"\014\215\321\227\254\211\045\305\352\317\102\327\331\271\345\024"
	"\342\124\216\325\071\134\322\031\003\215\043\321\011\365\367\176"
	"\204\156\106\250\260\140\052\343\042\366\003\321\347\201\361\346"
	"\227\152\170\312\370\201\052\242\004\353\231\145\170\041\270\354"
	"\125\047\367\110\246\071\131\074\242\344\345\312\017\332\064\130"
	"\267\311\170\311\270\102\230\075\355\071\347\111\273\220\261\172"
	"\213\072\051\171\230\306\370\324\036\200\121\346\130\347\231\345"
	"\360\104\072\115\004\167\010\110\375\061\026\160\136\044\143\310"
	"\327\317\033\361\153\030\024\204\047\232\015\221\237\253\074\373"
	"\032\315\273\120\364\241\030\170\244\346\377\370\155\145\000\265"
	"\342\174\375\034\220\277\247\170\107\307\021\367\344\160\116\261"
	"\123\224\055\174\055\353\027\217\040\302\006\303\075\161\377\204"
	"\024\061\166\232\015\111\244\153\342\304\146\234\062\133\206\272"
	"\265\344\212\211\002\267\017\022\165\144\102\006\262\261\371\077"
	"\014\315\212\372\337\327\250\252\061\065\074\136\124\312\001\227"
	"\164\123\163\323\144\144\250\217\035\274\217\027\107\333\010\016"
	"\034\330\244\063\172\232\356\162\261\277\025\124\033\355\255\062"
	"\335\077\073\352\322\256\047\261\343\222\052\215\017\063\040\067"
	"\143\250\120\002\354\123\224\035\332\117\221\166\133\241\121\232"
	"\265\124\061\045\137\213\006\206\223\021\140\277\052\063\345\014"
	"\010\006\145\104\327\202\326\073\244\011\350\003\022\056\102\017"
	"\052\274\351\174\117\340\305\352\050\144\126\160\120\007\052\347"
	"\104\322\212\030\176\060\161\305\235\333\172\254\266\176\337\250"
	"\305\247\236\376\061\365\117\042\266\304\230\066\233\321\317\237"
	"\331\150\250\011\206\206\176\304\251\152\066\311\232\266\305\173"
	"\255\153\237\210\044\011\207\037\007\274\373\241\050\054\044\004"
	"\241\024\271\370\272\335\346\025\267\225\215\127\061\357\200\120"
	"\040\120\273\074\361\253\305\007\177\252\252\176\335\324\073\032"
	"\043\133\276\364\350\054\004\146\146\004\200\253\311\046\355\022"
	"\345\202\214\070\303\067\031\035\175\363\013\250\337\077\367\260"
	"\113\133\250\012\074\174\210\120\274\150\373\113\227\355\056\105"
	"\166\167\005\342\237\377\122\107\125\326\173\011\001\375\065\264"
	"\125\233\063\361\065\050\202\315\256\153\130\060\067\372\135\100"
	"\164\054\025\332\057\046\144\353\023\113\156\012\070\346\311\215"
	"\364\151\276\042\300\240\135\050\142\132\234\317\244\001\160\150"
	"\017\320\137\032\224\243\306\334\320\120\145\073\213\333\002\277"
	"\351\073\261\173\322\116\215\213\140\124\233\276\005\350\245\125"
	"\364\345\231\365\040\207\273\333\255\072\331\046\067\171\233\250"
	"\277\004\171\235\135\357\175\153\052\162\111\146\047\356\104\042"
	"\224\157\224\225\143\000\207\205\071\274\333\115\332\221\327\135"
	"\321\164\026\245\255\321\015\224\137\247\042\203\106\130\160\375"
	"\133\032\151\360\172\144\311\245\106\224\213\242\101\032\163\200"
	"\274\243\116\242\132\224\160\055\262\214\177\347\316\121\264\167"
	"\302\036\377\037\372\206\263\362\077\004\313\014\256\074\103\272"
	"\065\000\364\355\156\267\312\323\075\155\171\144\135\123\100\112"
	"\171\117\145\247\206\366\114\343\036\004\005\167\066\243\204\354"
	"\070\264\162\243\330\071\173\067\076\343\276\334\076\366\152\224"
	"\163\262\125\342\261\062\240\233\255\240\300\216\174\027\346\033"
	"\111\227\157\277\026\161\151\246\221\062\174\140\210\336\025\107"
	"\304\257\215\336\234\220\355\034\175\325\063\012\105\241\215\376"
	"\202\215\023\106\220\013\323\336\171\300\072\303\344\025\066\163"
	"\267\203\131\342\210\003\064\246\076\133\203\314\352\311\212\161"
	"\251\265\362\124\074\252\303\366\301\121\103\303\213\005\055\121"
	"\172\066\237\043\247\354\127\343\134\014\312\312\112\105\064\112"
	"\134\054\205\347\124\347\151\001\031\371\345\312\366\312\153\310"
	"\117\026\330\014\050\005\260\360\311\043\364\237\043\210\311\354"
	"\225\250\017\006\161\314\341\327\331\053\025\013\102\011\001\336"
	"\267\351\274\335\354\061\141\006\201\350\032\310\105\066\047\070"
	"\142\325\056\034\060\034\210\232\153\374\306\052\110\157\306\332"
	"\032\104\360\023\270\205\112\034\261\105\326\020\101\314\133\276"
	"\330\101\367\132\170\065\064\357\200\210\241\167\125\041\015\121"
	"\175\007\025\243\210\166\145\376\150\205\033\364\170\134\352\006"
	"\104\305\374\261\345\030\106\207\006\136\330\153\025\036\217\366"
	"\012\142\042\212\132\061\072\304\036\322\120\177\146\343\152\363"
	"\140\324\225\330\257\316\256\341\272\341\350\255\273\375\014\367"
	"\132\375\072\336\054\364\003\322\314\020\140\376\213\357\044\032"
	"\056\142\310\233\152\305\105\336\343\164\350\111\036\122\113\220"
	"\227\210\051\170\012\155\016\166\127\140\363\236\140\246\052\313"
	"\125\270\230\104\235\114\343\155\373\154\250\253\227\307\106\042"
	"\106\243\233\243\132\076\100\353\003\271\012\226\043\336\232\163"
	"\340\275\156\173\005\117\241\134\043\322\171\202\077\117\201\257"
	"\013\121\064\066\256\111\246\170\247\050\216\011\264\210\240\042"
	"\135\324\264\320\172\010\141\353\326\025\213\045\164\364\354\070"
	"\264\267\062\355\235\076\247\125\250\024\361\002\332\170\274\100"
	"\264\205\222\024\212\046\144\252\116\234\263\174\373\163\274\023"
	"\312\061\010\174\327\216\150\247\326\002\233\137\335\132\334\334"
	"\152\223\357\321\175\066\011\073\222\271\077\107\244\133\254\102"
	"\126\101\014\233\107\007\063\336\257\332\053\313\132\326\212\033"
	"\270\342\257\167\050\246\120\056\216\333\101\307\215\251\043\247"
	"\137\111\171\316\236\326\114\123\032\210\376\327\063\243\022\351"
	"\075\265\311\312\204\034\376\130\056\371\252\143\340\264\354\334"
	"\017\304\226\342\212\237\150\177\243\247\274\211\117\330\065\256"
	"\324\252\130\106\160\253\365\073\131\111\020\223\132\344\273\260"
	"\270\272\302\201\167\312\020\371\135\371\022\114\327\061\373\164"
	"\327\222\124\122\313\306\105\036\324\024\034\223\035\070\052\002"
	"\106\277\247\133\013\046\255\203\060\270\326\212\306\056\214\054"
	"\326\354\020\230\356\000\346\310\047\235\271\070\141\063\227\330"
	"\205\257"
#define      date_z	1
#define      date	((&data[1863]))
	"\000"
#define      shll_z	10
#define      shll	((&data[1866]))
	"\145\171\071\033\227\252\163\212\361\362\150\061"
#define      tst1_z	22
#define      tst1	((&data[1877]))
	"\155\131\110\044\243\034\236\030\342\225\246\344\006\213\025\304"
	"\151\333\315\156\210\127\224"
#define      pswd_z	256
#define      pswd	((&data[1950]))
	"\155\241\017\131\111\250\364\313\307\135\232\377\365\162\204\244"
	"\216\001\222\310\326\336\055\117\122\163\140\300\141\054\175\316"
	"\316\215\050\027\066\034\342\375\172\174\374\157\357\201\024\175"
	"\202\247\105\247\353\325\075\324\035\123\311\341\260\026\113\177"
	"\076\141\050\356\365\347\104\345\240\367\372\031\212\151\064\040"
	"\243\102\310\216\027\006\143\064\131\054\026\012\103\141\211\201"
	"\302\262\160\267\231\265\234\071\255\227\123\070\001\207\130\244"
	"\312\041\063\341\047\226\025\201\303\054\213\007\215\024\211\120"
	"\306\372\007\140\257\244\232\134\074\355\224\075\165\355\342\077"
	"\017\025\040\067\254\066\270\157\142\103\167\360\130\000\100\037"
	"\372\110\177\252\355\032\006\051\007\233\147\174\211\111\274\230"
	"\137\334\317\014\023\210\173\165\314\363\145\044\363\246\104\356"
	"\356\303\230\333\336\237\005\345\072\154\142\303\266\036\134\026"
	"\373\054\042\016\264\236\204\200\221\352\245\205\220\351\163\177"
	"\255\013\132\213\252\140\161\345\314\323\251\203\362\006\231\356"
	"\062\273\374\346\132\201\147\353\153\014\160\374\365\344\173\242"
	"\360\326\056\233\066\237\200\003\163\052\206\146\060\040\124\142"
	"\333\121\111\066\322\261\041\076\275\222\072\263\166\266\126\146"
	"\214\204\001\302\043\202\305\227\255\114\375\335\154\121\100\110"
	"\242\212\176\130\205\163\250\330\346\010\230\110\065\025\027\003"
	"\243\077\032\331\134\375\327\326\171\324\106\150\125\132\346\330"
	"\001\054\061\206\237\331\136\206\342\367\316\027\015\345\033\260"
	"\044\066\212"
#define      chk1_z	22
#define      chk1	((&data[2255]))
	"\130\251\074\312\322\272\131\132\151\166\225\216\032\070\042\054"
	"\267\256\155\060\356\367\224\255\066"
#define      msg2_z	19
#define      msg2	((&data[2279]))
	"\052\142\061\301\136\177\037\355\130\303\373\247\270\262\075\222"
	"\007\315\260\370\374"
#define      xecc_z	15
#define      xecc	((&data[2303]))
	"\224\201\310\335\121\271\116\225\243\266\354\134\014\374\344\106"
	"\111\355"
#define      inlo_z	3
#define      inlo	((&data[2318]))
	"\275\012\013"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
